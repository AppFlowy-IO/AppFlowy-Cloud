// This file is @generated by prost-build.
/// *
/// Rid represents Redis stream message Id, which is a unique identifier
/// in scope of individual Redis stream - here workspace scope - assigned
/// to each update stored in Redis.
///
/// Default: "0-0"
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Rid {
  /// UNIX epoch timestamp in milliseconds.
  #[prost(fixed64, tag = "1")]
  pub timestamp: u64,
  /// In case when timestamps duplicate, this monotonically increasing
  /// sequence number is incremented and assigned.
  #[prost(uint32, tag = "2")]
  pub counter: u32,
}
/// *
/// SyncRequest message is send by either a server or a client, which informs about the
/// last collab state known to either party.
///
/// If other side has more recent data, it should send `Update` message in the response.
/// If other side has missing data, it should send its own `SyncRequest` in the response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SyncRequest {
  /// Last Redis stream ID of the update received from the server, concerning corresponding
  /// collab, this message refers to.It
  ///
  /// The `Rid.timestamp` field can be used to notify clients when was the last time,
  /// collab has been synchronised.
  #[prost(message, optional, tag = "1")]
  pub last_message_id: ::core::option::Option<Rid>,
  /// Yjs Doc state vector encoded using lib0 v1 encoding.
  #[prost(bytes = "vec", tag = "2")]
  pub state_vector: ::prost::alloc::vec::Vec<u8>,
}
/// *
/// Update message is send either in response to `SyncRequest` or independently by
/// the client/server. It contains the Yjs doc update that can represent incremental
/// changes made over corresponding collab, or full document state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Update {
  /// Redis stream message ID assigned to this update, after it has been stored by
  /// server in Redis.
  ///
  /// For updates send by client, this field is not set.
  #[prost(message, optional, tag = "1")]
  pub message_id: ::core::option::Option<Rid>,
  /// Flags used to inform about encoding details:
  /// - 0x00 - `payload` encoded using lib0 v1 encoding.
  /// - 0x01 - `payload` encoded using lib0 v2 encoding.
  ///
  /// NOTE: in the future we could also include `payload` compression.
  #[prost(uint32, tag = "2")]
  pub flags: u32,
  /// Binary update representing incremental changes over the collab,
  /// or entire collab state delta.
  #[prost(bytes = "vec", tag = "3")]
  pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// *
/// AwarenessUpdate message is send to inform about the latest changes in the
/// Yjs doc awareness state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AwarenessUpdate {
  /// Yjs awareness update encoded using lib0 v1 encoding.
  #[prost(bytes = "vec", tag = "1")]
  pub payload: ::prost::alloc::vec::Vec<u8>,
}
/// *
/// AccessChanged message is sent only by the server when we recognise, that
/// connected client has lost the access to a corresponding collab.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessChanged {
  /// Flag indicating if user has read access to corresponding collab.
  #[prost(bool, tag = "1")]
  pub can_read: bool,
  /// Flag indicating if user has write access to corresponding collab.
  #[prost(bool, tag = "2")]
  pub can_write: bool,
  /// (Optional) human readable comment about the reason for access change.
  #[prost(string, tag = "3")]
  pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CollabMessage {
  /// Unique collab identifier (UUID), which this message is related to.
  /// We're using string here, since it's easier to represent in web browser client.
  #[prost(string, tag = "1")]
  pub object_id: ::prost::alloc::string::String,
  /// Collab type - required by some of the collab read operations on the server.
  /// NOTE: hopefully we'll be able to get rid of it in the future.
  #[prost(int32, tag = "2")]
  pub collab_type: i32,
  #[prost(oneof = "collab_message::Data", tags = "3, 4, 5, 6")]
  pub data: ::core::option::Option<collab_message::Data>,
}
/// Nested message and enum types in `CollabMessage`.
pub mod collab_message {
  #[derive(Clone, PartialEq, ::prost::Oneof)]
  pub enum Data {
    #[prost(message, tag = "3")]
    SyncRequest(super::SyncRequest),
    #[prost(message, tag = "4")]
    Update(super::Update),
    #[prost(message, tag = "5")]
    AwarenessUpdate(super::AwarenessUpdate),
    #[prost(message, tag = "6")]
    AccessChanged(super::AccessChanged),
  }
}
